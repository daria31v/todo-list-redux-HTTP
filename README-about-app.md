All depends: npm install react-icons --save; npm i clsx; npm install redux; npm
install react-redux (бібліотеку React Redux); npm install
@redux-devtools/extension;

Iнтерфейс та логікa роботи програми:

Інтерфейс повинен складатися з кількох частин: Шапка з інформацією про завдання
та фільтри Форма з полем введення для створення нових завдань Список завдань У
шапці необхідно відображати: Кількість виконаних та невиконаних завдань Фільтри
списку завдань зі значеннями «All», «Active» та «Completed» У кожного елементу
списку завдань має бути: Абзац з текстом який вводив у форму користувач під час
створення завдання Чекбокс перемикання статусу «виконано» Кнопка видалення
завдання Кінцева мета - додаток.

---

Кожне завдання буде представлено об'єктом з наступними властивостями: id -
унікальний ідентифікатор; text - текст, який ввів користувач під час створення;
completed - прапор, що вказує, виконано завдання чи ні.

---

Проектування екшенів Екшени це події, які можуть статися в додатку, в тому числі
як реакція на дії користувача. Складемо список подій, які можуть бути в нашому
додатку: *Додати нове завдання з текстом, введеним користувачем *Видалити
завдання *Переключити статус завдання *Змінити значення фільтра статусу

---

Створюємо папку src/redux з наступною структурою файлів: actions.js - файл
оголошення екшенів програми; reducer.js - файл оголошення функцій-редюсерів для
оновлення стану; constants.js - файл для зберігання констант (наприклад значень
фільтру статусу); selectors.js - файл оголошення функцій-селекторів; store.js -
файл створення стор Redux

Якщо в додатку багато різних даних, то підійде «feature based» підхід, де під
кожну сутність створюється окрема папка усередині папки redux. Усередині кожної
сутності є стандартний набір файлів. В результаті більше файлів, але код логіки
Redux поділений на сутності та більш структурований.

---

Збережемо можливі значення фільтра як об'єкта, щоб повторно використовувати їх у
різних місцях програми: компоненті StatusFilter для обчислення поточного
активного фільтра та відправки екшенів зміни фільтра, компоненті TaskList для
обчислення списку видимих завдань, а також функції-редюсері в якій потім будемо
обробляти екшен зміни фільтра. Використовуємо метод Object.freeze() для того,
щоб «заморозити» об'єкт значень фільтра та запобігти випадковій зміні за
посиланням у місцях імпорту.

---

Компоненту StatusFilter потрібно значення фільтра з властивості statusFilter
стану Redux, тому функція-селектор виглядатиме як state => state.filters.status.
Компоненту TaskList необхідний масив завдань із властивості tasks та значення
фільтра із властивості statusFilter. На основі цих значень ми можемо вирахувати
масив завдань, які необхідно рендерувати в інтерфейсі. Компоненту TaskCounter
необхідний масив завдань із властивості tasks стану Redux, тому функція-селектор
виглядатиме як state => state.tasks. На базі цих даних ми можемо обчислити
похідні дані кількості активних і виконаних завдань. Один і той же селектор може
використовуватися в декількох місцях програми, що призводить до дублювання коду,
як, наприклад, у наших компонентах TaskList, StatusFilter та TaskCounter. Щоб
уникнути цього та ще більше структурувати код, всі функції-селектори
оголошуються в окремому файлі, наприклад, в src/redux/selectors.js, після чого
імпортуються до компонентів.

---

Actions - це об'єкти, які передають дані з компонентів у стор, тим самим
сигналізуючи про те, яка подія сталася в інтерфейсі. Вони являються єдиним
джерелом інформації для стору. Екшени це статичні об'єкти, значення властивості
payload яких неможливо задати динамічно. Генератори екшенів (Action Creators) -
функції, які можуть приймати аргументи, після чого створюють та повертають
екшени з однаковим значенням властивості type, але різними payload. Вони можуть
мати побічні ефекти, наприклад, заповнювати властивості за замовчуванням або
генерувати унікальний ідентифікатор об'єкта завдання. Створимо генератори
екшенів для нашої програми.

---

Правила редюсерів Редюсери повинні бути чистими функціями та дотримуватися
списку правил:

Не можна змінювати аргументи (state та action). Редюсери мають лише обчислювати
нове значення стану з урахуванням цих аргументів. Не можна змінювати стан
(state). Натомість редюсери повинні робити оновлення, копіюючи існуючий стан та
вносячи зміни до копії. Редюсери не повинні виконувати жодних «побічних
ефектів». Наприклад, запуск таймера, виконання HTTP-запиту, зміна значення поза
функцією або її аргументів, генерація випадкових чисел чи рядків тощо. Як
виконувати побічні ефекти ми розглянемо далі, поки просто пам'ятаєте - редюсер
має бути чистою функцією. Отримуючи аргументи, він має обчислити наступний стан
та повернути його. Жодних побічних ефектів. Жодних мутацій. Тільки обчислення
нової версії стану.

---

Redux Toolkit «під капотом» використовує бібліотеку Immer, яка значно спрощує
логіку роботи зі станом, дозволяючи нам писати код оновлення стану в редюсері
так, ніби ми безпосередньо змінювали стан. Насправді редюсери отримують копію
стану, а Immer перетворює всі мутації на еквівалентні операції оновлення.
